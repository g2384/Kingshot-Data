<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Events Timeline</title>
    <link rel="stylesheet" href="timeline.css">
    <style>
        /* Monday indicator styling */
        .day-cell.monday-start {
            border-left: 3px solid #007acc;
            position: relative;
        }

        .day-cell.monday-start::before {
            content: '';
            position: absolute;
            left: -3px;
            top: 0;
            bottom: 0;
            width: 3px;
            background: linear-gradient(to bottom, #007acc 0%, #005b96 100%);
            box-shadow: 1px 0 2px rgba(0, 122, 204, 0.3);
        }

        .week-indicator {
            font-size: 10px;
            font-weight: bold;
            color: #007acc;
            text-align: center;
            margin-bottom: 2px;
            padding: 1px 2px;
            background: rgba(0, 122, 204, 0.1);
            border-radius: 3px;
            border: 1px solid rgba(0, 122, 204, 0.2);
        }

        /* Enhance day cell styling for better visual hierarchy */
        .day-cell {
            position: relative;
            padding: 8px 4px;
        }

        .day-number {
            font-weight: bold;
            text-align: center;
        }

        .weekday {
            font-size: 11px;
            text-align: center;
            color: #666;
        }

        /* Make Monday weekday text more prominent */
        .day-cell.monday-start .weekday {
            color: #007acc;
            font-weight: 600;
        }

        .day-cell.monday-start .day-number {
            color: #007acc;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Left Control Panel -->
        <div class="control-panel">
            <h2>Timeline Controls</h2>

            <div class="control-group">
                <label for="serverAge">Server Age (days):</label>
                <input type="number" id="serverAge" min="1" value="1" style="width: 60px; display: inline-block;">
                <div style="margin-top: 8px; font-size: 12px; color: #666;">
                    <strong>Current UTC:</strong> <span id="currentUtcDate"></span> (<span id="currentUtcWeekday"></span>)
                </div>
            </div>

            <!-- Info Button -->
            <button class="info-button" onclick="openEventInfoModal()">
                Event Information & Exclusions
            </button>

            <!-- Event Legend with Filtering -->
            <div class="legend">
                <h3>Event Categories (Click to Filter)</h3>
                <div style="margin-bottom: 10px;">
                    <button class="filter-button active" onclick="toggleAllEvents(true)" style="margin-right: 5px;">Show All</button>
                    <button class="filter-button" onclick="toggleAllEvents(false)">Hide All</button>
                </div>
                <div class="legend-item clickable active" data-category="one-off" onclick="toggleByCategory('one-off')">
                    <div class="color-box one-off"></div>
                    <span>One-off Events</span>
                </div>
                <div class="legend-item clickable active" data-category="solo" onclick="toggleByCategory('solo')">
                    <div class="color-box solo"></div>
                    <span>Solo Events</span>
                </div>
                <div class="legend-item clickable active" data-category="alliance" onclick="toggleByCategory('alliance')">
                    <div class="color-box alliance"></div>
                    <span>Alliance Events</span>
                </div>
                <div class="legend-item clickable active" data-category="hog" onclick="toggleByCategory('hog')">
                    <div class="color-box hog"></div>
                    <span>Hall of Governors</span>
                </div>
                <div class="legend-item clickable active" data-category="online" onclick="toggleByCategory('online')">
                    <div class="color-box online"></div>
                    <span>Online Events</span>
                </div>
                <div class="legend-item clickable active" data-category="power-up" onclick="toggleByCategory('power-up')">
                    <div class="color-box power-up"></div>
                    <span>Power-up Events</span>
                </div>
            </div>

            <!-- Event List -->
            <div class="event-list">
                <h3>Event Visibility</h3>
                <div id="eventListContainer"></div>
            </div>
        </div>

        <!-- Right Timeline Panel -->
        <div class="timeline-panel">
            <div class="timeline-container" id="timelineContainer">
                <table class="timeline-table" id="timelineTable">
                    <thead id="timelineHeader">
                        <!-- Headers will be generated by JavaScript -->
                    </thead>
                    <tbody id="timelineBody">
                        <!-- Timeline rows will be generated by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Modal Popup -->
    <div id="eventInfoModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Event Information & Exclusions</h2>
                <button class="modal-close" onclick="closeEventInfoModal()">&times;</button>
            </div>
            <div class="modal-body">
                <h3>Why Some Events Are Not Displayed</h3>
                <p>This timeline focuses on regular, predictable events that players can plan for. Some events are
                    excluded for the following reasons:</p>

                <div class="excluded-event">
                    <div class="excluded-event-title">üèõÔ∏è Sanctuary Battle</div>
                    <div class="excluded-event-reason">
                        Sanctuary Battle is a weekly event with a consistent recurrence.
                        However, its exact weekday trigger varies by server and cannot be reliably predicted for new
                        servers due to limited data.
                        For instance, if both servers are launched on Sunday, one might see the event on Tuesday, while
                        the other may encounter it on Sunday.
                    </div>
                </div>

                <div class="excluded-event">
                    <div class="excluded-event-title">üèõÔ∏è Alliance Championship</div>
                    <div class="excluded-event-reason">
                        Alliance Championship is a weekly event that lasts 7 days. It first begins on the
                        Monday following the server's ~10th day and continues to repeat every Monday thereafter.
                    </div>
                </div>

                <div class="excluded-event">
                    <div class="excluded-event-title">üéØ Special Limited Events</div>
                    <div class="excluded-event-reason">
                        Holiday events, anniversary celebrations, and other limited-time events are announced separately
                        and don't follow regular patterns.
                        These are typically communicated through official game announcements or suddenly appears.
                    </div>
                </div>

                <h3>Known Issues</h3>
                <p>Some event dates may not be accurate at the beginning:</p>
                <ul>
                    <li>Fishing Tournament: may start a few days earlier than expected</li>
                </ul>

                <h3>Planning Your Activities</h3>
                <p>Use this timeline to:</p>
                <ul>
                    <li>Plan your resource management around upcoming events</li>
                    <li>Coordinate alliance activities</li>
                    <li>Optimize your daily login rewards and participation</li>
                    <li>Prepare for power-up events by saving materials in advance</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const fixedColumns =
        {
            0: ["hog-1", "hog-2", "hog-4", "hog-sg-1"],
            1: ["hero-roulette-G1-1",
                "steel-edge",
                "plan-your-city",
                "power-up",
                "hero-roulette-G1-2",
                "working-overtime",
                "develop-new-tech",
                "working-overtime-3",
                "stand-of-arms-1",
                "city-development-1",
                "grow-your-heroes"],
            2: ["alliance-mobilization", "alliance-mobilization-post"],
            3: ["desert-trial-1", "desert-trial", "defeat-nearby-beasts"]
        };
        
        // Event Icons Mapping - maps event titles to icon image paths
        const eventIcons = {
            "7 Daily Sign-in Gift": "event-default.webp",
            "Path of Growth": "event-path-of-growth.webp",
            "Burst of Life": "event-default.webp",
            "Desert Trial": "event-desert-trial.webp",
            "Hall of Governors": "event-hall-of-governors.webp",
            "Hero Roulette": "event-hero-roulette.webp",
            "Defeat Nearby Beasts": "event-defeat-nearby-beasts.webp",
            "Alliance Mobilization": "event-default.webp",
            "Fishing Tournament": "event-default.webp",
            "Viking Vengeance": "event-default.webp",
            "Steel Edge": "event-steel-edge.webp",
            "Cesares Fury": "event-cesares-fury.webp",
            "Plan Your City": "event-working-overtime.webp",
            "Power Up": "event-power-up.webp",
            "Swordland Showdown": "event-default.webp",
            "All Out": "event-all-out.webp",
            "Working Overtime": "event-working-overtime.webp",
            "Develop New Tech": "event-develop-new-tech.webp",
            "Castle Battle": "event-default.webp",
            "Age of Renewal": "event-default.webp",
            "Milestone": "event-default.webp",
            "Stand of Arms": "event-stand-of-arms.webp",
            "City Development": "event-city-development.webp",
            "Call of the Sovereign": "event-call-of-the-sovereign.webp",
            "Mystic Divination": "event-default.webp",
            "Grow Your Heroes": "event-default.webp",
            "Strongest Governor": "event-strongest-governor.webp",
            "Eternity's Reach": "event-default.webp"
        };
        
        // Function to get icon path for an event
        function getEventIcon(eventTitle) {
            return `../images/icons/${eventIcons[eventTitle]}` || "event-default.webp";
        }
        
        // 2025-02-28 first Vikings Vengeance, then every 14 days. For all servers
        // TODO add tests
        const eventsData = {
            "events": [
                {
                    "id": 1,
                    "title": "7 Daily Sign-in Gift",
                    "duration": 7,
                    "isRepeating": false,
                    "occurrenceInterval": 0,
                    "firstOccurrenceDay": 1,
                    "category": "one-off",
                    "requirements": []
                },
                {
                    "id": 2,
                    "title": "Path of Growth",
                    "duration": 7,
                    "isRepeating": false,
                    "occurrenceInterval": 0,
                    "firstOccurrenceDay": 1,
                    "category": "one-off",
                    "hasStages": true,
                    "stages": [
                        { "day": 1, "note": "" },
                        { "day": 2, "note": "" },
                        { "day": 3, "note": "" },
                        { "day": 4, "note": "Require Conquest Skill Books, Expedition Skill Manuals" },
                        { "day": 5, "note": "Require 800 minutes of any Speedup" },
                        { "day": 6, "note": "" },
                        { "day": 7, "note": "" }
                    ],
                    "requirements": ["TC Lv. 5"]
                },
                {
                    "id": 3,
                    "title": "Burst of Life",
                    "duration": 7,
                    "isRepeating": false,
                    "occurrenceInterval": 0,
                    "firstOccurrenceDay": 1,
                    "category": "one-off",
                    "requirements": []
                },
                {
                    "id": "desert-trial-1",
                    "title": "Desert Trial",
                    "duration": 3,
                    "isRepeating": false,
                    "occurrenceInterval": 0,
                    "firstOccurrenceDay": 3,
                    "category": "solo",
                    "requirements": []
                },
                {
                    "id": "hog-1",
                    "title": "Hall of Governors",
                    "duration": 5,
                    "isRepeating": false,
                    "occurrenceInterval": 0,
                    "firstOccurrenceDay": 6,
                    "category": "hog",
                    "hasStages": true,
                    "stages": [
                        { "day": 1, "note": "Raise 1 Power through Construction, Raise 1 Power through Research" },
                        { "day": 2, "note": "Hero shards" },
                        { "day": 3, "note": "Promote troops" },
                        { "day": 4, "note": "Stamina" },
                        { "day": 5, "note": "Raise 1 Power through Construction, Raise 1 Power through Research, promote troops" },
                        { "day": 6, "note": "" },
                        { "day": 7, "note": "" }
                    ],
                    "requirements": ["1st"]
                },
                {
                    "id": "hero-roulette-G1-1",
                    "title": "Hero Roulette",
                    "duration": 3,
                    "isRepeating": false,
                    "occurrenceInterval": 0,
                    "firstOccurrenceDay": 7,
                    "category": "hog",
                    "requirements": ["1st, Saul"]
                },
                {
                    "id": "desert-trial",
                    "title": "Desert Trial",
                    "duration": 3,
                    "isRepeating": true,
                    "occurrenceInterval": 14,
                    "firstOccurrenceWeek": 3,
                    "occurrenceWeekday": "Wednesday",
                    "category": "solo",
                    "requirements": []
                },
                {
                    "id": "defeat-nearby-beasts",
                    "title": "Defeat Nearby Beasts",
                    "duration": 3,
                    "isRepeating": true,
                    "occurrenceInterval": 14,
                    "firstOccurrenceWeek": 4,
                    "occurrenceWeekday": "Tuesday",
                    "category": "solo",
                    "requirements": []
                },
                {
                    "id": "alliance-mobilization",
                    "title": "Alliance Mobilization",
                    "duration": 7,
                    "isRepeating": true,
                    "occurrenceInterval": 14,
                    "firstOccurrenceWeek": 3,
                    "maxOccurrences": 3,
                    "occurrenceWeekday": "Monday",
                    "category": "alliance",
                    "requirements": ["Alliance Rank 20+"]
                },
                {
                    "id": 13,
                    "title": "Fishing Tournament",
                    "duration": 3,
                    "isRepeating": true,
                    "occurrenceInterval": 14,
                    "firstOccurrenceWeek": 3,
                    "maxOccurrences": 2,
                    "occurrenceWeekday": "Tuesday",
                    "category": "solo",
                    "requirements": []
                },
                {
                    "id": 14,
                    "title": "Viking Vengeance",
                    "duration": 3,
                    "isRepeating": true,
                    "occurrenceInterval": 14,
                    "firstOccurrenceDay": 7,
                    "occurrenceWeekday": "Tuesday",
                    "category": "online",
                    "requirements": []
                },
                { // all events above are accurate
                    "id": "steel-edge",
                    "title": "Steel Edge",
                    "duration": 2,
                    "appearAfter": ["hog-1"],
                    "category": "power-up",
                    "note": "Use Forgehammer, Gear Enhancement, Exclusive Gear Widget, Gather Resources",
                    "requirements": []
                },
                {
                    "id": 16,
                    "title": "Cesares Fury",
                    "duration": 3,
                    "isRepeating": true,
                    "occurrenceInterval": 21,
                    "firstOccurrenceDay": 11,
                    "maxOccurrences": 2,
                    "category": "solo",
                    "requirements": []
                },
                {
                    "id": "plan-your-city",
                    "title": "Plan Your City",
                    "duration": 2,
                    "appearAfter": ["steel-edge"],
                    "category": "power-up",
                    "maxOccurrences": 1,
                    "note": "Raise 1 Power through Construction, Raise 1 Power through Research",
                    "requirements": []
                },
                {
                    "id": "power-up",
                    "title": "Power Up",
                    "duration": 2,
                    "appearAfter": ["plan-your-city"],
                    "category": "power-up",
                    "maxOccurrences": 1,
                    "note": "Raise 1 Power through Construction, Raise 1 Power through Research, promote troops",
                    "requirements": []
                },
                {
                    "id": "hog-2",
                    "title": "Hall of Governors",
                    "duration": 6,
                    "firstOccurrenceWeek": 4,
                    "occurrenceWeekday": "Monday",
                    "category": "hog",
                    "hasStages": true,
                    "stages": [
                        { "day": 1, "note": "Raise 1 Power through Construction, Raise 1 Power through Research" },
                        { "day": 2, "note": "Play Hero Roulette, Use 1 Rare Hero Shard to ascend Heroes, Use 1 Epic Hero Shard to ascend Heroes, Use 1 Mythic Hero Shard to ascend Heroes, Gather 50 Bread in the Wilderness, Gather 50 Wood in the Wilderness, Gather 10 Stone in the Wilderness, Gather 2 Iron in the Wilderness" },
                        { "day": 3, "note": "Raise 1 Power by training/promoting troops" },
                        { "day": 4, "note": "Gather 50 Bread in the Wilderness, Gather 50 Wood in the Wilderness, Gather 10 Stone in the Wilderness, Gather 2 Iron in the Wilderness, Raise 1 Power through Research" },
                        { "day": 5, "note": "Use 1 Hero Gear Forgehammer(s), Use 100 Hero Gear Enhancement XP, Use 1 Widget for Hero Exclusive Gear, Raise 1 Power through Construction, Raise 1 Power through Research, Raise 1 Power by training/promoting troops" },
                        { "day": 6, "note": "Raise Governor Gear max score by 1, Raise 1 Power through Construction, Raise 1 Power through Research, Raise 1 Power by training/promoting troops" }
                    ],
                    "requirements": ["2nd"]
                },
                {
                    "id": 21,
                    "title": "Swordland Showdown",
                    "duration": 7,
                    "isRepeating": true,
                    "occurrenceInterval": 14,
                    "firstOccurrenceWeek": 4,
                    "maxOccurrences": 2,
                    "category": "online",
                    "occurrenceWeekday": "Monday",
                    "note": "",
                    "requirements": []
                },
                {
                    "id": "hero-roulette-G1-2",
                    "title": "Hero Roulette",
                    "duration": 3,
                    "occurrenceInterval": 14,
                    "firstOccurrenceWeek": 4,
                    "occurrenceWeekday": "Tuesday",
                    "category": "hog",
                    "requirements": ["2nd, Saul"]
                },
                {
                    "id": 23,
                    "title": "All Out",
                    "duration": 3,
                    "isRepeating": true,
                    "occurrenceInterval": 28,
                    "firstOccurrenceDay": 15,
                    "maxOccurrences": 2,
                    "category": "solo",
                    "occurrenceWeekday": "Friday",
                    "requirements": []
                },
                {
                    "id": "working-overtime",
                    "title": "Working Overtime",
                    "duration": 2,
                    "appearAfter": ["hog-2"],
                    "category": "power-up",
                    "note": "Raise 1 Power through Construction, Raise 1 Power through Research, promote troops",
                    "requirements": []
                },
                {
                    "id": "develop-new-tech",
                    "title": "Develop New Tech",
                    "duration": 2,
                    "appearAfter": ["working-overtime"],
                    "category": "power-up",
                    "note": "Raise 1 Power through Research",
                    "requirements": []
                },
                // week 8 or 9
                {
                    "id": "castle-battle-1",
                    "title": "Castle Battle",
                    "duration": 1,
                    "firstOccurrenceDay": 54,
                    "category": "online",
                    "requirements": []
                },
                {
                    "id": "alliance-mobilization-post",
                    "title": "Alliance Mobilization",
                    "duration": 7,
                    "isRepeating": true,
                    "occurrenceInterval": 14,
                    "firstOccurrenceWeek": 9,
                    "occurrenceWeekday": "Monday",
                    "category": "alliance",
                    "requirements": []
                },
                {
                    "id": "age-of-renewal",
                    "title": "Age of Renewal",
                    "duration": 7,
                    "isRepeating": false,
                    "firstOccurrenceWeek": 10,
                    "occurrenceWeekday": "Monday",
                    "category": "solo",
                    "requirements": []
                },
                {
                    "id": "hog-4",
                    "title": "Hall of Governors",
                    "duration": 7,
                    "firstOccurrenceWeek": 10,
                    "occurrenceWeekday": "Monday",
                    "category": "hog",
                    "requirements": ["4th"],
                    "hasStages": true,
                    "stages": [
                        { "day": 1, "note": "??" },
                        { "day": 2, "note": "??" },
                        { "day": 3, "note": "??" },
                        { "day": 4, "note": "??" },
                        { "day": 5, "note": "??" },
                        { "day": 6, "note": "??" },
                        { "day": 7, "note": "??" }
                    ]
                },
                {
                    "id": "all-out-2",
                    "title": "All Out",
                    "duration": 2,
                    "isRepeating": true,
                    "occurrenceInterval": 14,
                    "firstOccurrenceWeek": 10,
                    "occurrenceWeekday": "Friday",
                    "category": "solo",
                    "requirements": []
                },
                {
                    "id": "castle-battle-2",
                    "title": "Castle Battle",
                    "duration": 1,
                    "isRepeating": true,
                    "occurrenceInterval": 14,
                    "firstOccurrenceWeek": 10,
                    "occurrenceWeekday": "Saturday",
                    "category": "online",
                    "requirements": []
                },
                {
                    "id": "event-5",
                    "title": "Milestone",
                    "duration": 1,
                    "firstOccurrenceWeek": 10,
                    "occurrenceWeekday": "Sunday",
                    "category": "one-off",
                    "requirements": ["Truegold available in Daily Missions"]
                },
                {
                    "id": "event-6",
                    "title": "Milestone",
                    "duration": 1,
                    "firstOccurrenceWeek": 11,
                    "occurrenceWeekday": "Tuesday",
                    "category": "one-off",
                    "requirements": ["Pet Gen 2 available"]
                },
                {
                    "id": "working-overtime-3",
                    "title": "Working Overtime",
                    "duration": 2,
                    "appearAfter": ["hog-4"],
                    "category": "power-up",
                    "requirements": []
                },
                {
                    "id": "stand-of-arms-1",
                    "title": "Stand of Arms",
                    "duration": 2,
                    "appearAfter": ["working-overtime-3"],
                    "category": "power-up",
                    "requirements": []
                },
                {
                    "id": "city-development-1",
                    "title": "City Development",
                    "duration": 2,
                    "appearAfter": ["stand-of-arms-1"],
                    "category": "power-up",
                    "requirements": []
                },
                {
                    "id": "call-of-the-sovereign",
                    "title": "Call of the Sovereign",
                    "duration": 3,
                    "firstOccurrenceWeek": 11,
                    "occurrenceWeekday": "Tuesday",
                    "category": "one-of",
                    "requirements": []
                },
                {
                    "id": "mystic-divination",
                    "title": "Mystic Divination",
                    "duration": 2,
                    "firstOccurrenceWeek": 11,
                    "occurrenceInterval": 28,
                    "occurrenceWeekday": "Friday",
                    "category": "shop",
                    "requirements": []
                },
                {
                    "id": "cesares-fury-post",
                    "title": "Cesares Fury",
                    "duration": 3,
                    "isRepeating": true,
                    "occurrenceInterval": 21,
                    "firstOccurrenceDay": 11,
                    "category": "solo",
                    "occurrenceWeekday": "Saturday",
                    "requirements": []
                },
                {
                    "id": "grow-your-heroes",
                    "title": "Grow Your Heroes",
                    "duration": 2,
                    "appearAfter": ["city-development-1"],
                    "category": "power-up",
                    "requirements": []
                },
                {
                    "id": "hog-sg-1",
                    "title": "Strongest Governor",
                    "duration": 7,
                    "firstOccurrenceWeek": 12,
                    "occurrenceWeekday": "Monday",
                    "category": "hog",
                    "requirements": ["1st"],
                    "hasStages": true,
                    "stages": [
                        { "day": 1, "note": "??" },
                        { "day": 2, "note": "??" },
                        { "day": 3, "note": "??" },
                        { "day": 4, "note": "??" },
                        { "day": 5, "note": "??" },
                        { "day": 6, "note": "??" },
                        { "day": 7, "note": "??" }
                    ]
                },
                {
                    "id": "eternity-reach-post",
                    "title": "Eternity's Reach",
                    "duration": 1,
                    "isRepeating": true,
                    "occurrenceInterval": 14,
                    "firstOccurrenceWeek": 12,
                    "occurrenceWeekday": "Tuesday",
                    "category": "online",
                    "requirements": []
                }
            ]
        };

        // ========== CONSTANTS AND CONFIGURATION ==========
        const WEEKDAYS = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        const WEEKDAY_MAP = {
            'Sunday': 0, 'Monday': 1, 'Tuesday': 2, 'Wednesday': 3,
            'Thursday': 4, 'Friday': 5, 'Saturday': 6
        };
        const MONDAY_INDEX = 1;
        const MAX_PRECALCULATED_DAY = 1000;
        const ADDITIONAL_DAYS_ON_SCROLL = 20;
        const DEFAULT_VISIBLE_DAYS = 50;

        // ========== UTILITY FUNCTIONS ==========

        // Calculate weekday index based on alignment system
        function calculateWeekdayIndex(day) {
            const offsetFromAlignment = day - alignmentDay;
            let weekdayIndex = (startWeekday + offsetFromAlignment) % 7;
            if (weekdayIndex < 0) {
                weekdayIndex += 7;
            }
            return weekdayIndex;
        }

        // Check if a specific day is Monday
        function isDayMonday(day) {
            return calculateWeekdayIndex(day) === MONDAY_INDEX;
        }

        // Get weekday name for a specific day
        function getWeekdayName(day) {
            return WEEKDAYS[calculateWeekdayIndex(day)];
        }

        // Convert weekday name to index with validation
        function getWeekdayIndex(weekdayName) {
            const index = WEEKDAY_MAP[weekdayName];
            return index !== undefined ? index : null;
        }

        // Get the actual calendar date for a given day number
        function getCalendarDate(day) {
            const now = new Date();
            const serverAge = parseInt(document.getElementById('serverAge').value) || 1;
            // Calculate the date for day 1
            const day1Date = new Date(now);
            day1Date.setUTCDate(day1Date.getUTCDate() - (serverAge - 1));
            
            // Calculate the date for the requested day
            const targetDate = new Date(day1Date);
            targetDate.setUTCDate(day1Date.getUTCDate() + (day - 1));
            
            const month = String(targetDate.getUTCMonth() + 1).padStart(2, '0');
            const dayNum = String(targetDate.getUTCDate()).padStart(2, '0');
            
            return `${month}/${dayNum}`;
        }

        // Create day cell with proper styling and content
        function createDayCell(day) {
            const dayCell = document.createElement('td');
            dayCell.className = 'day-cell';
            
            const dateStr = getCalendarDate(day);

            if (isMonday(day)) {
                dayCell.className += ' monday-start';
                const weekNum = getWeekNumber(day);
                dayCell.innerHTML = `<div class="week-indicator">Week ${weekNum}</div><div class="day-number" style="font-size: 14px; font-weight: 700;">${dateStr}</div><div class="weekday" style="font-size: 10px;">Day ${day} ‚Ä¢ ${getWeekdayForDay(day)}</div>`;
            } else {
                dayCell.innerHTML = `<div class="day-number" style="font-size: 14px; font-weight: 700;">${dateStr}</div><div class="weekday" style="font-size: 10px;">Day ${day} ‚Ä¢ ${getWeekdayForDay(day)}</div>`;
            }

            return dayCell;
        }

        // Create and populate event cell for a specific day and column
        function createEventCell(day, colIndex) {
            // Find visible events that occur on this day in this column
            const eventsOnThisDay = eventColumns[colIndex].filter(occurrence =>
                day >= occurrence.startDay && day <= occurrence.endDay && eventVisibility[sanitizeTitle(occurrence.event.title)]
            );

            if (eventsOnThisDay.length > 0) {
                const occurrence = eventsOnThisDay[0];
                const event = occurrence.event;
                const dayInEvent = day - occurrence.startDay + 1;

                // For events without stages spanning multiple days, skip rendering cells after the first day
                if (!event.hasStages && event.duration > 1 && day !== occurrence.startDay) {
                    return null; // Signal to skip this cell
                }

                const eventCell = document.createElement('td');
                eventCell.className = 'event-cell';
                eventCell.className += ` ${getEventCssClass(event)}`;

                // For events without stages spanning multiple days, merge cells with rowspan
                if (!event.hasStages && event.duration > 1 && day === occurrence.startDay) {
                    eventCell.setAttribute('rowspan', event.duration);
                }

                // Get event icon
                const iconPath = getEventIcon(event.title);
                
                // Build HTML content with icon and structured layout
                let cellHTML = '';
                
                // Add day indicator in top-right corner (for events with stages or multi-day events)
                if (event.hasStages || (event.duration > 1 && day !== occurrence.startDay)) {
                    cellHTML += `<div class="event-info day-indicator">Day ${dayInEvent}</div>`;
                }
                
                // Add event text content wrapper
                cellHTML += `<div class="event-text-content">`;
                
                // Add event title with icon (only on first day)
                if (day === occurrence.startDay) {
                    cellHTML += `<div class="event-title-wrapper">`;
                    cellHTML += `<img src="${iconPath}" alt="${event.title}" class="event-icon" onerror="this.src='https://via.placeholder.com/32x32/999999/FFFFFF?text=?'">`;
                    cellHTML += `<div class="event-title">${event.title}</div>`;
                    cellHTML += `</div>`;
                }
                
                // Add stage information if available
                if (event.hasStages && event.stages && event.stages[dayInEvent - 1]) {
                    const stage = event.stages[dayInEvent - 1];
                    if (stage.note) {
                        const emoji = noteToEmoji(stage.note);
                        cellHTML += `<div class="stage-note">${emoji}</div>`;
                    }
                }
                
                // Add general note if it's the first day
                if (day === occurrence.startDay && event.note) {
                    cellHTML += `<div class="event-note">${event.note}</div>`;
                }
                
                // Add requirements on first day
                if (day === occurrence.startDay && event.requirements.length > 0) {
                    cellHTML += `<div class="requirements">${event.requirements.join(', ')}</div>`;
                }
                
                cellHTML += `</div>`; // Close event-text-content
                
                eventCell.innerHTML = cellHTML;
                return eventCell;
            }

            // No event on this day, return empty cell
            const eventCell = document.createElement('td');
            eventCell.className = 'event-cell';
            return eventCell;
        }

        // Create a complete timeline row for a given day
        function createTimelineRow(day) {
            const row = document.createElement('tr');
            row.className = 'timeline-row';

            // Add day cell
            row.appendChild(createDayCell(day));

            // Add event cells
            for (let colIndex = 0; colIndex < eventColumns.length; colIndex++) {
                const cell = createEventCell(day, colIndex);
                // Only append if cell is not null (null means it's part of a merged cell)
                if (cell !== null) {
                    row.appendChild(cell);
                }
            }

            return row;
        }

        // Update UI after visibility changes
        function refreshUI() {
            generateEventList();
            generateTimeline();
        }

        // Update visibility for multiple events
        function updateEventVisibility(eventTitles, visible) {
            eventTitles.forEach(title => {
                const sanitizedTitle = typeof title === 'string' ? sanitizeTitle(title) : title;
                eventVisibility[sanitizedTitle] = visible;
            });
        }

        // Handle event dependencies by finding the latest end day
        function resolveEventDependencies(event, resolvedDependencies) {
            if (!event.appearAfter || event.appearAfter.length === 0) {
                return null;
            }

            let latestDependencyEnd = 0;
            for (const dependencyId of event.appearAfter) {
                if (resolvedDependencies[dependencyId]) {
                    const dependencyOccurrences = resolvedDependencies[dependencyId];
                    const lastOccurrence = dependencyOccurrences[dependencyOccurrences.length - 1];
                    if (lastOccurrence) {
                        latestDependencyEnd = Math.max(latestDependencyEnd, lastOccurrence.endDay);
                    }
                }
            }

            return latestDependencyEnd + 1; // Start the day after the latest dependency ends
        }

        // Modal utility functions
        function showModal(modalId) {
            const modal = document.getElementById(modalId);
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        function hideModal(modalId) {
            const modal = document.getElementById(modalId);
            modal.classList.remove('show');
            document.body.style.overflow = 'auto';
        }

        // Calculate event start day based on week/weekday or direct day specification
        function calculateEventStartDay(event) {
            if (event.firstOccurrenceWeek && event.occurrenceWeekday) {
                return getDayForWeekAndWeekday(event.firstOccurrenceWeek, event.occurrenceWeekday);
            } else {
                let startDay = event.firstOccurrenceDay;
                // If event has a specific weekday requirement, adjust the start day
                if (event.occurrenceWeekday) {
                    startDay = adjustForWeekday(startDay, event.occurrenceWeekday);
                }
                return startDay;
            }
        }

        // ========== TIMELINE STATE ==========
        let currentStartDay = 1;
        let visibleDays = DEFAULT_VISIBLE_DAYS;
        let startWeekday = 0; // Sunday
        let alignmentDay = 1; // The day that should align with the selected weekday
        let timelineData = [];
        let eventColumns = [];
        let preCalculatedOccurrences = [];
        let eventVisibility = {}; // Track visibility state of events

        // ========== LOCAL STORAGE FUNCTIONS ==========
        const STORAGE_KEYS = {
            SERVER_AGE: 'timeline_server_age',
            EVENT_VISIBILITY: 'timeline_event_visibility',
            SAVED_UTC_DATE: 'timeline_saved_utc_date'
        };

        function saveToLocalStorage() {
            const serverAge = parseInt(document.getElementById('serverAge').value) || 1;
            const currentUtcDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
            
            localStorage.setItem(STORAGE_KEYS.SERVER_AGE, serverAge.toString());
            localStorage.setItem(STORAGE_KEYS.EVENT_VISIBILITY, JSON.stringify(eventVisibility));
            localStorage.setItem(STORAGE_KEYS.SAVED_UTC_DATE, currentUtcDate);
        }

        function loadFromLocalStorage() {
            const savedServerAge = localStorage.getItem(STORAGE_KEYS.SERVER_AGE);
            const savedEventVisibility = localStorage.getItem(STORAGE_KEYS.EVENT_VISIBILITY);
            const savedUtcDate = localStorage.getItem(STORAGE_KEYS.SAVED_UTC_DATE);
            
            return {
                serverAge: savedServerAge ? parseInt(savedServerAge) : null,
                eventVisibility: savedEventVisibility ? JSON.parse(savedEventVisibility) : null,
                savedUtcDate: savedUtcDate || null
            };
        }

        function calculateDayDifference(savedDate, currentDate) {
            const saved = new Date(savedDate);
            const current = new Date(currentDate);
            const diffTime = current - saved;
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            return diffDays;
        }

        // Function to sanitize event titles for use as identifiers
        function sanitizeTitle(title) {
            return title.toLowerCase()
                .replace(/[^a-z0-9\-\s]/g, '') // Remove special characters
                .replace(/\s+/g, '-') // Replace spaces with hyphens
                .replace(/-+/g, '-') // Replace multiple hyphens with single hyphen
                .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
        }

        // Function to get CSS class name for an event
        function getEventCssClass(event) {
            return 'event-' + sanitizeTitle(event.title);
        }

        const emojiMap = {
            'construction': 'üèóÔ∏è',
            'research': 'üìö',
            'roulette': 'üé≤',
            'shard': 'üíé',
            'hero': 'ü¶∏',
            'bread': 'üçû',
            'wood': 'ü™µ',
            'stone': 'ü™®',
            'iron': '‚õèÔ∏è',
            'troops': '‚öîÔ∏è',
            'training': '‚öîÔ∏è',
            'promoting': '‚¨ÜÔ∏è',
            'stamina': '‚ö°',
            'speedup': '‚è±Ô∏è',
            'gear': 'üõ°Ô∏è',
            'forgehammer': 'üî®',
            'enhancement': '‚¨ÜÔ∏è',
            'widget': 'üîß',
            'resources': 'üì¶',
            'skill': 'üìñ',
            'manual': 'üìó'
        };
        const emojiMapKeys = Object.keys(emojiMap); // Cache the keys once

        // Function to convert note text to appropriate emojis
        function noteToEmoji(note) {
            if (!note) return '';

            var notes = note.split(/,\s*/);
            let emojis = '';
            // Convert text to lowercase for matching
            const lowerNote = note.toLowerCase();

            for (let i = 0; i < notes.length; i++) {
                const originalNote = notes[i];
                const lowerNote = originalNote.toLowerCase();

                for (let j = 0; j < emojiMapKeys.length; j++) {
                    const key = emojiMapKeys[j];
                    if (lowerNote.includes(key)) {
                        emojis += `<span title="${originalNote}" alt="${originalNote}">${emojiMap[key]}</span>`;
                        break;
                    }
                }
            }


            // If no specific emoji found, use a generic info emoji
            return emojis || '‚ÑπÔ∏è';
        }

        // Initialize timeline when page loads
        document.addEventListener('DOMContentLoaded', function () {
            initializeControls();
            generateTimeline();
        });

        function initializeControls() {
            // Display current UTC date and weekday
            updateCurrentUtcDisplay();
            
            // Load saved data from localStorage
            const savedData = loadFromLocalStorage();
            const currentUtcDate = new Date().toISOString().split('T')[0];
            
            let serverAge = 1; // Default value
            
            // Auto-adjust server age based on date difference
            if (savedData.serverAge !== null && savedData.savedUtcDate !== null) {
                const dayDifference = calculateDayDifference(savedData.savedUtcDate, currentUtcDate);
                serverAge = savedData.serverAge + dayDifference;
                
                // Ensure server age is at least 1
                if (serverAge < 1) {
                    serverAge = 1;
                }
                
                console.log(`Loaded server age: ${savedData.serverAge}, Days passed: ${dayDifference}, New server age: ${serverAge}`);
            }
            
            // Set the server age input
            document.getElementById('serverAge').value = serverAge;
            alignmentDay = serverAge;
            
            // Server age input event listener
            document.getElementById('serverAge').addEventListener('input', function () {
                const newServerAge = parseInt(this.value) || 1;
                // Update alignment day to match server age
                alignmentDay = newServerAge;
                generateTimeline();
                saveToLocalStorage(); // Save when server age changes
            });

            // Initialize event visibility
            if (savedData.eventVisibility !== null) {
                // Load saved visibility
                eventVisibility = savedData.eventVisibility;
            } else {
                // Initialize all events visible by default
                eventsData.events.forEach(event => {
                    eventVisibility[sanitizeTitle(event.title)] = true;
                });
            }

            // Generate event list (this must come after eventVisibility is set)
            generateEventList();
            
            // Update legend items visual state based on loaded visibility
            updateLegendItemsState();
            
            // Save initial state after loading
            saveToLocalStorage();
        }
        
        function updateLegendItemsState() {
            // Get unique categories
            const categories = [...new Set(eventsData.events.map(e => e.category))];
            
            categories.forEach(category => {
                const eventsInCategory = eventsData.events.filter(e => e.category === category);
                const allVisible = eventsInCategory.every(e => eventVisibility[sanitizeTitle(e.title)]);
                
                const legendItem = document.querySelector(`.legend-item[data-category="${category}"]`);
                if (legendItem) {
                    if (allVisible) {
                        legendItem.classList.add('active');
                    } else {
                        legendItem.classList.remove('active');
                    }
                }
            });
        }
        
        function updateCurrentUtcDisplay() {
            const now = new Date();
            const year = now.getUTCFullYear();
            const month = String(now.getUTCMonth() + 1).padStart(2, '0');
            const day = String(now.getUTCDate()).padStart(2, '0');
            const dateStr = `${year}-${month}-${day}`;
            
            const weekdayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const weekdayStr = weekdayNames[now.getUTCDay()];
            
            document.getElementById('currentUtcDate').textContent = dateStr;
            document.getElementById('currentUtcWeekday').textContent = weekdayStr;
        }

        function generateEventList() {
            const container = document.getElementById('eventListContainer');
            container.innerHTML = '';

            eventsData.events.forEach(event => {
                const sanitizedTitle = sanitizeTitle(event.title);
                const eventToggle = document.createElement('div');
                eventToggle.className = `event-toggle ${event.category} ${eventVisibility[sanitizedTitle] ? '' : 'disabled'}`;
                eventToggle.onclick = () => toggleEvent(sanitizedTitle);

                eventToggle.innerHTML = `
                    <div class="toggle-switch ${eventVisibility[sanitizedTitle] ? 'active' : ''}">
                        <div class="toggle-slider"></div>
                    </div>
                    <div class="event-toggle-content">
                        <div class="event-toggle-title">${event.title}</div>
                        <div class="event-toggle-info">
                            Duration: ${event.duration} days
                            ${event.isRepeating ? ` ‚Ä¢ Repeats every ${event.occurrenceInterval} days` : ''}
                            ${event.requirements.length > 0 ? `<br>${event.requirements.join(', ')}` : ''}
                        </div>
                    </div>
                `;
                container.appendChild(eventToggle);
            });
        }

        function getWeekdayForDay(day) {
            return getWeekdayName(day);
        }

        function isMonday(day) {
            return isDayMonday(day);
        }

        function getWeekNumber(day) {
            // Find the first Monday on or after day 1
            let firstMondayDay = 1;
            while (!isMonday(firstMondayDay)) {
                firstMondayDay++;
            }

            // If the day is before the first Monday, it's considered week 1
            if (day < firstMondayDay) {
                return 1;
            }

            // Calculate week number based on days since first Monday
            // The first Monday starts week 2 if there were partial days before it
            const baseWeek = firstMondayDay > 1 ? 2 : 1;
            return Math.floor((day - firstMondayDay) / 7) + baseWeek;
        }

        function calculateEventOccurrences(event, maxDay, resolvedDependencies = {}) {
            const occurrences = [];

            if (!event.isRepeating) {
                // Single occurrence event
                let startDay;

                // Handle appearAfter dependencies
                const dependencyStartDay = resolveEventDependencies(event, resolvedDependencies);
                if (dependencyStartDay !== null) {
                    startDay = dependencyStartDay;
                } else {
                    startDay = calculateEventStartDay(event);
                }

                if (startDay <= maxDay) {
                    occurrences.push({
                        startDay: startDay,
                        endDay: startDay + event.duration - 1,
                        event: event
                    });
                }
            } else {
                // Repeating event
                let occurrenceCount = 0;
                let currentStartDay;

                // Handle appearAfter dependencies for repeating events
                const dependencyStartDay = resolveEventDependencies(event, resolvedDependencies);
                if (dependencyStartDay !== null) {
                    currentStartDay = dependencyStartDay;
                } else {
                    currentStartDay = calculateEventStartDay(event);
                }

                while (currentStartDay <= maxDay && (!event.maxOccurrences || occurrenceCount < event.maxOccurrences)) {
                    occurrences.push({
                        startDay: currentStartDay,
                        endDay: currentStartDay + event.duration - 1,
                        event: event
                    });

                    currentStartDay += event.occurrenceInterval;
                    occurrenceCount++;
                }
            }

            return occurrences;
        }

        function adjustForWeekday(baseDay, targetWeekdayName) {
            const targetWeekday = getWeekdayIndex(targetWeekdayName);
            if (targetWeekday === null) {
                return baseDay; // Return original if weekday name is invalid
            }

            const baseDayWeekday = calculateWeekdayIndex(baseDay);

            // Calculate how many days to adjust to reach the target weekday
            let adjustment = targetWeekday - baseDayWeekday;
            if (adjustment < 0) {
                adjustment += 7; // Move to next week if target day has passed
            }

            return baseDay + adjustment;
        }

        // Helper function to get the fixed column for an event ID, or null if not fixed
        function getFixedColumnForEvent(eventId) {
            for (const [colIndex, eventIds] of Object.entries(fixedColumns)) {
                if (eventIds.includes(eventId)) {
                    return parseInt(colIndex);
                }
            }
            return null;
        }

        // Helper function to check if an event is assigned to a fixed column
        function isEventInFixedColumn(eventId) {
            return getFixedColumnForEvent(eventId) !== null;
        }

        function getDayForWeekAndWeekday(weekNumber, weekdayName) {
            const targetWeekday = getWeekdayIndex(weekdayName);
            if (targetWeekday === null) {
                return 1; // Return day 1 if weekday name is invalid
            }

            // Find the first Monday on or after day 1
            let firstMondayDay = 1;
            while (!isMonday(firstMondayDay)) {
                firstMondayDay++;
            }

            // Calculate the start of the requested week
            let weekStartDay;
            if (weekNumber === 1) {
                // Week 1 starts from day 1
                weekStartDay = 1;
            } else {
                // Week 2 starts from the first Monday, subsequent weeks follow
                const baseWeek = firstMondayDay > 1 ? 2 : 1;
                if (weekNumber < baseWeek) {
                    weekStartDay = 1;
                } else {
                    weekStartDay = firstMondayDay + ((weekNumber - baseWeek) * 7);
                }
            }

            // Find the Monday of the target week
            let mondayOfWeek = weekStartDay;
            if (weekNumber > 1 || firstMondayDay === 1) {
                // For week 2+ or if first Monday is day 1, find the Monday of this week
                while (!isMonday(mondayOfWeek) && mondayOfWeek <= weekStartDay + 6) {
                    mondayOfWeek++;
                }
                // If no Monday found in the week range, use the calculated Monday
                if (!isMonday(mondayOfWeek)) {
                    mondayOfWeek = firstMondayDay + ((weekNumber - (firstMondayDay > 1 ? 2 : 1)) * 7);
                }
            }

            // Calculate the target day based on the Monday of the week
            let dayOffset = targetWeekday - MONDAY_INDEX;
            if (dayOffset < 0) {
                dayOffset += 7; // Handle Sunday (0) by going to previous week's Sunday
            }

            return mondayOfWeek + dayOffset;
        }

        function preCalculateAllOccurrences() {
            // Pre-calculate all event occurrences up to MAX_PRECALCULATED_DAY
            const allOccurrences = [];
            const resolvedDependencies = {};

            // Create a set to track which events have been processed
            const processedEvents = new Set();

            // Function to process events in dependency order
            function processEvent(event) {
                // Skip if already processed
                const eventKey = event.id || event.title;
                if (processedEvents.has(eventKey)) {
                    return;
                }

                // Process dependencies first
                if (event.appearAfter && event.appearAfter.length > 0) {
                    for (const dependencyId of event.appearAfter) {
                        const dependencyEvent = eventsData.events.find(e =>
                            (e.id === dependencyId) || (e.title === dependencyId)
                        );
                        if (dependencyEvent && !processedEvents.has(dependencyId)) {
                            processEvent(dependencyEvent);
                        }
                    }
                }

                // Calculate occurrences for this event
                const occurrences = calculateEventOccurrences(event, MAX_PRECALCULATED_DAY, resolvedDependencies);
                allOccurrences.push(...occurrences);

                // Store resolved dependencies for future events
                resolvedDependencies[eventKey] = occurrences;
                processedEvents.add(eventKey);
            }

            // Process all events
            eventsData.events.forEach(event => {
                processEvent(event);
            });

            // Sort by start day, then by event priority (fixed events first)
            allOccurrences.sort((a, b) => {
                if (a.startDay !== b.startDay) return a.startDay - b.startDay;
                // Fixed events get priority
                const aEventKey = a.event.id || a.event.title;
                const bEventKey = b.event.id || b.event.title;
                const aIsFixed = isEventInFixedColumn(aEventKey);
                const bIsFixed = isEventInFixedColumn(bEventKey);
                if (aIsFixed && !bIsFixed) return -1;
                if (!aIsFixed && bIsFixed) return 1;
                return 0;
            });

            return allOccurrences;
        }

        function determineEventColumns() {
            // Pre-calculate all occurrences if not done already
            if (preCalculatedOccurrences.length === 0) {
                preCalculatedOccurrences = preCalculateAllOccurrences();
            }

            // Determine which columns are reserved based on fixedColumns dictionary
            const reservedColumns = new Set(Object.keys(fixedColumns).map(k => parseInt(k)));

            // Determine the maximum number of fixed columns needed
            let maxFixedColumn = Math.max(...Array.from(reservedColumns), -1);

            // Initialize columns array with enough space for fixed columns
            const columns = [];
            for (let i = 0; i <= maxFixedColumn; i++) {
                columns[i] = [];
            }

            // First pass: assign fixed events to their designated columns
            preCalculatedOccurrences.forEach(occurrence => {
                const eventKey = occurrence.event.id || occurrence.event.title;
                const fixedColumn = getFixedColumnForEvent(eventKey);

                if (fixedColumn !== null) {
                    columns[fixedColumn].push(occurrence);
                    occurrence.assignedColumn = fixedColumn; // Track assignment
                }
            });

            // Second pass: efficiently pack non-fixed events into available spaces (skip reserved columns)
            preCalculatedOccurrences.forEach(occurrence => {
                const eventKey = occurrence.event.id || occurrence.event.title;

                // Skip if already assigned as a fixed event
                if (isEventInFixedColumn(eventKey)) {
                    return;
                }

                let assignedColumn = -1;

                // Try to find the first available column that can accommodate this event
                // Skip columns that are reserved for fixed events
                for (let colIndex = 0; colIndex < columns.length; colIndex++) {
                    if (!reservedColumns.has(colIndex) && canFitInColumn(occurrence, columns[colIndex])) {
                        columns[colIndex].push(occurrence);
                        occurrence.assignedColumn = colIndex;
                        assignedColumn = colIndex;
                        break;
                    }
                }

                // If no existing column can fit this event, create a new one
                if (assignedColumn === -1) {
                    columns.push([occurrence]);
                    occurrence.assignedColumn = columns.length - 1;
                }
            });

            // Ensure all reserved columns exist (even if empty)
            reservedColumns.forEach(colIndex => {
                if (!columns[colIndex]) {
                    columns[colIndex] = [];
                }
            });

            // Fill any gaps in the columns array to maintain proper indexing
            const maxColumnIndex = Math.max(columns.length - 1, maxFixedColumn);
            for (let i = 0; i <= maxColumnIndex; i++) {
                if (!columns[i]) {
                    columns[i] = [];
                }
            }

            return columns;
        }

        function canFitInColumn(newOccurrence, columnOccurrences) {
            // Check if the new occurrence overlaps with any existing occurrence in the column
            return !columnOccurrences.some(existing =>
                !(newOccurrence.endDay < existing.startDay || newOccurrence.startDay > existing.endDay)
            );
        }

        function generateTimeline() {
            const table = document.getElementById('timelineTable');
            const header = document.getElementById('timelineHeader');
            const body = document.getElementById('timelineBody');

            // Clear existing content
            header.innerHTML = '';
            body.innerHTML = '';

            // Reset pre-calculated occurrences when timeline parameters change
            preCalculatedOccurrences = [];

            // Calculate event columns (this will trigger pre-calculation)
            eventColumns = determineEventColumns();

            // Create header row
            const headerRow = document.createElement('tr');
            headerRow.innerHTML = '<th class="day-header">Day</th>';

            // Add event column headers
            for (let i = 0; i < eventColumns.length; i++) {
                const th = document.createElement('th');
                th.className = 'event-header';
                th.textContent = `Events ${i + 1}`;
                headerRow.appendChild(th);
            }

            header.appendChild(headerRow);

            // Generate timeline rows
            for (let day = currentStartDay; day < currentStartDay + visibleDays; day++) {
                body.appendChild(createTimelineRow(day));
            }

            // Add infinite scroll
            addInfiniteScroll();
        }

        function addInfiniteScroll() {
            const container = document.getElementById('timelineContainer');

            container.addEventListener('scroll', function () {
                if (container.scrollTop + container.clientHeight >= container.scrollHeight - 100) {
                    // Load more days
                    loadMoreDays();
                }
            });
        }

        function toggleEvent(sanitizedTitle) {
            eventVisibility[sanitizedTitle] = !eventVisibility[sanitizedTitle];
            saveToLocalStorage(); // Save when event visibility changes
            refreshUI();
        }

        function toggleAllEvents(show) {
            const eventTitles = eventsData.events.map(event => sanitizeTitle(event.title));
            updateEventVisibility(eventTitles, show);
            
            // Update all legend items visual state
            const legendItems = document.querySelectorAll('.legend-item.clickable');
            legendItems.forEach(item => {
                if (show) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
            
            saveToLocalStorage(); // Save when visibility changes
            refreshUI();
        }

        function toggleByCategory(category) {
            const eventsInCategory = eventsData.events.filter(event => event.category === category);
            const allVisible = eventsInCategory.every(event => eventVisibility[sanitizeTitle(event.title)]);
            const eventTitles = eventsInCategory.map(event => sanitizeTitle(event.title));

            updateEventVisibility(eventTitles, !allVisible);
            
            // Update legend item visual state
            const legendItem = document.querySelector(`.legend-item[data-category="${category}"]`);
            if (legendItem) {
                if (!allVisible) {
                    legendItem.classList.add('active');
                } else {
                    legendItem.classList.remove('active');
                }
            }
            
            saveToLocalStorage(); // Save when visibility changes
            refreshUI();
        }

        function loadMoreDays() {
            const body = document.getElementById('timelineBody');
            const startDay = currentStartDay + visibleDays;

            for (let day = startDay; day < startDay + ADDITIONAL_DAYS_ON_SCROLL; day++) {
                body.appendChild(createTimelineRow(day));
            }

            visibleDays += ADDITIONAL_DAYS_ON_SCROLL;
        }

        // Modal functions
        function openEventInfoModal() {
            showModal('eventInfoModal');
        }

        function closeEventInfoModal() {
            hideModal('eventInfoModal');
        }

        // Close modal when clicking outside of it
        document.getElementById('eventInfoModal').addEventListener('click', function (e) {
            if (e.target === this) {
                closeEventInfoModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('eventInfoModal');
                if (modal.classList.contains('show')) {
                    closeEventInfoModal();
                }
            }
        });
    </script>
</body>

</html>
