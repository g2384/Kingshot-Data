<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Events Timeline</title>
    <link rel="stylesheet" href="timeline.css">
    <style>
        /* Monday indicator styling */
        .day-cell.monday-start {
            border-left: 3px solid #007acc;
            position: relative;
        }

        .day-cell.monday-start::before {
            content: '';
            position: absolute;
            left: -3px;
            top: 0;
            bottom: 0;
            width: 3px;
            background: linear-gradient(to bottom, #007acc 0%, #005b96 100%);
            box-shadow: 1px 0 2px rgba(0, 122, 204, 0.3);
        }

        .week-indicator {
            font-size: 10px;
            font-weight: bold;
            color: #007acc;
            text-align: center;
            margin-bottom: 2px;
            padding: 1px 2px;
            background: rgba(0, 122, 204, 0.1);
            border-radius: 3px;
            border: 1px solid rgba(0, 122, 204, 0.2);
        }

        /* Enhance day cell styling for better visual hierarchy */
        .day-cell {
            position: relative;
            padding: 8px 4px;
        }

        .day-number {
            font-weight: bold;
            text-align: center;
        }

        .weekday {
            font-size: 11px;
            text-align: center;
            color: #666;
        }

        /* Make Monday weekday text more prominent */
        .day-cell.monday-start .weekday {
            color: #007acc;
            font-weight: 600;
        }

        .day-cell.monday-start .day-number {
            color: #007acc;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Left Control Panel -->
        <div class="control-panel">
            <h2>Timeline Controls</h2>

            <div class="control-group">
                <label for="alignmentDay">Alignment Day:</label>
                <input type="number" id="alignmentDay" min="1" value="1" style="width: 60px; display: inline-block;">
                <label for="startWeekday" id="dayWeekdayLabel" style="margin-left: 10px;">Day 1 Weekday:</label>
                <select id="startWeekday">
                    <option value="0" selected>Sunday</option>
                    <option value="1">Monday</option>
                    <option value="2">Tuesday</option>
                    <option value="3">Wednesday</option>
                    <option value="4">Thursday</option>
                    <option value="5">Friday</option>
                    <option value="6">Saturday</option>
                </select>
            </div>

            <!-- Info Button -->
            <button class="info-button" onclick="openEventInfoModal()">
                Event Information & Exclusions
            </button>

            <!-- Event Legend -->
            <div class="legend">
                <h3>Event Categories</h3>
                <div class="legend-item">
                    <div class="color-box one-off"></div>
                    <span>One-off Events</span>
                </div>
                <div class="legend-item">
                    <div class="color-box solo"></div>
                    <span>Solo Events</span>
                </div>
                <div class="legend-item">
                    <div class="color-box alliance"></div>
                    <span>Alliance Events</span>
                </div>
                <div class="legend-item">
                    <div class="color-box hog"></div>
                    <span>Hall of Governors</span>
                </div>
                <div class="legend-item">
                    <div class="color-box online"></div>
                    <span>Online Events</span>
                </div>
                <div class="legend-item">
                    <div class="color-box power-up"></div>
                    <span>Power-up Events</span>
                </div>
            </div>

            <!-- Filter Controls -->
            <div class="filter-controls">
                <h3>Quick Filters</h3>
                <button class="filter-button active" onclick="toggleAllEvents(true)">Show All</button>
                <button class="filter-button" onclick="toggleAllEvents(false)">Hide All</button>
                <button class="filter-button" onclick="toggleByCategory('one-off')">One-off</button>
                <button class="filter-button" onclick="toggleByCategory('solo')">Solo</button>
                <button class="filter-button" onclick="toggleByCategory('alliance')">Alliance</button>
                <button class="filter-button" onclick="toggleByCategory('hog')">HoG</button>
                <button class="filter-button" onclick="toggleByCategory('online')">Online</button>
                <button class="filter-button" onclick="toggleByCategory('power-up')">Power-up</button>
            </div>

            <!-- Event List -->
            <div class="event-list">
                <h3>Event Visibility</h3>
                <div id="eventListContainer"></div>
            </div>
        </div>

        <!-- Right Timeline Panel -->
        <div class="timeline-panel">
            <div class="timeline-container" id="timelineContainer">
                <table class="timeline-table" id="timelineTable">
                    <thead id="timelineHeader">
                        <!-- Headers will be generated by JavaScript -->
                    </thead>
                    <tbody id="timelineBody">
                        <!-- Timeline rows will be generated by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Modal Popup -->
    <div id="eventInfoModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Event Information & Exclusions</h2>
                <button class="modal-close" onclick="closeEventInfoModal()">&times;</button>
            </div>
            <div class="modal-body">
                <h3>Why Some Events Are Not Displayed</h3>
                <p>This timeline focuses on regular, predictable events that players can plan for. Some events are
                    excluded for the following reasons:</p>

                <div class="excluded-event">
                    <div class="excluded-event-title">üèõÔ∏è Sanctuary Battle</div>
                    <div class="excluded-event-reason">
                        Sanctuary Battle is a weekly event with a consistent recurrence.
                        However, its exact weekday trigger varies by server and cannot be reliably predicted for new
                        servers due to limited data.
                        For instance, if both servers are launched on Sunday, one might see the event on Tuesday, while
                        the other may encounter it on Sunday.
                    </div>
                </div>

                <div class="excluded-event">
                    <div class="excluded-event-title">üèõÔ∏è Alliance Championship</div>
                    <div class="excluded-event-reason">
                        Alliance Championship is a weekly event that lasts 7 days. It first begins on the
                        Monday following the server's ~10th day and continues to repeat every Monday thereafter.
                    </div>
                </div>

                <div class="excluded-event">
                    <div class="excluded-event-title">üéØ Special Limited Events</div>
                    <div class="excluded-event-reason">
                        Holiday events, anniversary celebrations, and other limited-time events are announced separately
                        and don't follow regular patterns.
                        These are typically communicated through official game announcements or suddenly appears.
                    </div>
                </div>

                <h3>Known Issues</h3>
                <p>Some event dates may not be accurate at the beginning:</p>
                <ul>
                    <li>Fishing Tournament: may start a few days earlier than expected</li>
                </ul>

                <h3>Planning Your Activities</h3>
                <p>Use this timeline to:</p>
                <ul>
                    <li>Plan your resource management around upcoming events</li>
                    <li>Coordinate alliance activities</li>
                    <li>Optimize your daily login rewards and participation</li>
                    <li>Prepare for power-up events by saving materials in advance</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const fixedColumns = 
        {
            0: ["hog-1", "hog-2"],
            1: ["hero-roulette-G1-1", "steel-edge", "plan-your-city", "power-up", "hero-roulette-G1-2", "working-overtime", "develop-new-tech"],
            2: ["alliance-mobilization"],
            3: ["desert-trial-1", "desert-trial", "defeat-nearby-beasts"]
        };
        const eventsData = {
            "events": [
                {
                    "id": 1,
                    "title": "7 Daily Sign-in Gift",
                    "duration": 7,
                    "isRepeating": false,
                    "occurrenceInterval": 0,
                    "firstOccurrenceDay": 1,
                    "category": "one-off",
                    "requirements": []
                },
                {
                    "id": 2,
                    "title": "Path of Growth",
                    "duration": 7,
                    "isRepeating": false,
                    "occurrenceInterval": 0,
                    "firstOccurrenceDay": 1,
                    "category": "one-off",
                    "hasStages": true,
                    "stages": [
                        { "day": 1, "note": "" },
                        { "day": 2, "note": "" },
                        { "day": 3, "note": "" },
                        { "day": 4, "note": "Require Conquest Skill Books, Expedition Skill Manuals" },
                        { "day": 5, "note": "Require 800 minutes of any Speedup" },
                        { "day": 6, "note": "" },
                        { "day": 7, "note": "" }
                    ],
                    "requirements": ["TC Lv. 5"]
                },
                {
                    "id": 3,
                    "title": "Burst of Life",
                    "duration": 7,
                    "isRepeating": false,
                    "occurrenceInterval": 0,
                    "firstOccurrenceDay": 1,
                    "category": "one-off",
                    "requirements": []
                },
                {
                    "id": "desert-trial-1",
                    "title": "Desert Trial",
                    "duration": 3,
                    "isRepeating": false,
                    "occurrenceInterval": 0,
                    "firstOccurrenceDay": 3,
                    "category": "solo",
                    "requirements": []
                },
                {
                    "id": "hog-1",
                    "title": "Hall of Governors",
                    "duration": 5,
                    "isRepeating": false,
                    "occurrenceInterval": 0,
                    "firstOccurrenceDay": 6,
                    "category": "hog",
                    "hasStages": true,
                    "stages": [
                        { "day": 1, "note": "Raise 1 Power through Construction, Raise 1 Power through Research" },
                        { "day": 2, "note": "Hero shards" },
                        { "day": 3, "note": "Promote troops" },
                        { "day": 4, "note": "Stamina" },
                        { "day": 5, "note": "Raise 1 Power through Construction, Raise 1 Power through Research, promote troops" },
                        { "day": 6, "note": "" },
                        { "day": 7, "note": "" }
                    ],
                    "requirements": ["1st"]
                },
                {
                    "id": "hero-roulette-G1-1",
                    "title": "Hero Roulette",
                    "duration": 3,
                    "isRepeating": false,
                    "occurrenceInterval": 0,
                    "firstOccurrenceDay": 7,
                    "category": "hog",
                    "requirements": ["1st, Saul"]
                },
                {
                    "id": "desert-trial",
                    "title": "Desert Trial",
                    "duration": 3,
                    "isRepeating": true,
                    "occurrenceInterval": 14,
                    "firstOccurrenceWeek": 3,
                    "occurrenceWeekday": "Wednesday",
                    "category": "solo",
                    "requirements": []
                },
                {
                    "id": "defeat-nearby-beasts",
                    "title": "Defeat Nearby Beasts",
                    "duration": 3,
                    "isRepeating": true,
                    "occurrenceInterval": 14,
                    "firstOccurrenceWeek": 4,
                    "occurrenceWeekday": "Tuesday",
                    "category": "solo",
                    "requirements": []
                },
                {
                    "id": "alliance-mobilization",
                    "title": "Alliance Mobilization",
                    "duration": 7,
                    "isRepeating": true,
                    "occurrenceInterval": 14,
                    "firstOccurrenceWeek": 3,
                    "occurrenceWeekday": "Monday",
                    "category": "alliance",
                    "requirements": ["Alliance Rank 20+"]
                },
                {
                    "id": 13,
                    "title": "Fishing Tournament",
                    "duration": 3,
                    "isRepeating": true,
                    "occurrenceInterval": 14,
                    "firstOccurrenceWeek": 3,
                    "occurrenceWeekday": "Tuesday",
                    "category": "solo",
                    "requirements": []
                },
                {
                    "id": 14,
                    "title": "Viking Vengeance",
                    "duration": 3,
                    "isRepeating": true,
                    "occurrenceInterval": 14,
                    "firstOccurrenceDay": 7,
                    "occurrenceWeekday": "Tuesday",
                    "category": "online",
                    "requirements": []
                },
                { // all events above are accurate
                    "id": "steel-edge",
                    "title": "Steel Edge",
                    "duration": 2,
                    "appearAfter": ["hog-1"],
                    "category": "power-up",
                    "note": "Use Forgehammer, Gear Enhancement, Exclusive Gear Widget, Gather Resources",
                    "requirements": []
                },
                {
                    "id": 16,
                    "title": "Cesares Fury",
                    "duration": 3,
                    "isRepeating": true,
                    "occurrenceInterval": 21,
                    "firstOccurrenceDay": 11,
                    "category": "solo",
                    "requirements": []
                },
                {
                    "id": "plan-your-city",
                    "title": "Plan Your City",
                    "duration": 2,
                    "appearAfter": ["steel-edge"],
                    "category": "power-up",
                    "maxOccurrences": 1,
                    "note": "Raise 1 Power through Construction, Raise 1 Power through Research",
                    "requirements": []
                },
                {
                    "id": "power-up",
                    "title": "Power Up",
                    "duration": 2,
                    "appearAfter": ["plan-your-city"],
                    "category": "power-up",
                    "maxOccurrences": 1,
                    "note": "Raise 1 Power through Construction, Raise 1 Power through Research, promote troops",
                    "requirements": []
                },
                {
                    "id": "hog-2",
                    "title": "Hall of Governors",
                    "duration": 6,
                    "firstOccurrenceWeek": 4,
                    "occurrenceWeekday": "Monday",
                    "category": "hog",
                    "hasStages": true,
                    "stages": [
                        { "day": 1, "note": "Raise 1 Power through Construction, Raise 1 Power through Research" },
                        { "day": 2, "note": "Play Hero Roulette, Use 1 Rare Hero Shard to ascend Heroes, Use 1 Epic Hero Shard to ascend Heroes, Use 1 Mythic Hero Shard to ascend Heroes, Gather 50 Bread in the Wilderness, Gather 50 Wood in the Wilderness, Gather 10 Stone in the Wilderness, Gather 2 Iron in the Wilderness" },
                        { "day": 3, "note": "Raise 1 Power by training/promoting troops" },
                        { "day": 4, "note": "Gather 50 Bread in the Wilderness, Gather 50 Wood in the Wilderness, Gather 10 Stone in the Wilderness, Gather 2 Iron in the Wilderness, Raise 1 Power through Research" },
                        { "day": 5, "note": "Use 1 Hero Gear Forgehammer(s), Use 100 Hero Gear Enhancement XP, Use 1 Widget for Hero Exclusive Gear, Raise 1 Power through Construction, Raise 1 Power through Research, Raise 1 Power by training/promoting troops" },
                        { "day": 6, "note": "Raise Governor Gear max score by 1, Raise 1 Power through Construction, Raise 1 Power through Research, Raise 1 Power by training/promoting troops" }
                    ],
                    "requirements": ["2nd"]
                },
                {
                    "id": 21,
                    "title": "Swordland Showdown",
                    "duration": 7,
                    "isRepeating": true,
                    "occurrenceInterval": 14,
                    "firstOccurrenceWeek": 4,
                    "category": "online",
                    "occurrenceWeekday": "Monday",
                    "note": "",
                    "requirements": []
                },
                {
                    "id": "hero-roulette-G1-2",
                    "title": "Hero Roulette",
                    "duration": 3,
                    "occurrenceInterval": 14,
                    "firstOccurrenceWeek": 4,
                    "occurrenceWeekday": "Tuesday",
                    "category": "hog",
                    "requirements": ["2nd, Saul"]
                },
                {
                    "id": 23,
                    "title": "All Out",
                    "duration": 3,
                    "isRepeating": true,
                    "occurrenceInterval": 28,
                    "firstOccurrenceDay": 15,
                    "category": "solo",
                    "occurrenceWeekday": "Friday",
                    "requirements": []
                },
                {
                    "id": "working-overtime",
                    "title": "Working Overtime",
                    "duration": 2,
                    "appearAfter": ["hog-2"],
                    "category": "power-up",
                    "maxOccurrences": 2,
                    "note": "Raise 1 Power through Construction, Raise 1 Power through Research, promote troops",
                    "requirements": []
                },
                {
                    "id": "develop-new-tech",
                    "title": "Develop New Tech",
                    "duration": 2,
                    "appearAfter": ["working-overtime"],
                    "category": "power-up",
                    "maxOccurrences": 2,
                    "note": "Raise 1 Power through Research",
                    "requirements": []
                },
            ]
        };

        // ========== CONSTANTS AND CONFIGURATION ==========
        const WEEKDAYS = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        const WEEKDAY_MAP = {
            'Sunday': 0, 'Monday': 1, 'Tuesday': 2, 'Wednesday': 3,
            'Thursday': 4, 'Friday': 5, 'Saturday': 6
        };
        const MONDAY_INDEX = 1;
        const MAX_PRECALCULATED_DAY = 1000;
        const ADDITIONAL_DAYS_ON_SCROLL = 20;
        const DEFAULT_VISIBLE_DAYS = 50;

        // ========== UTILITY FUNCTIONS ==========
        
        // Calculate weekday index based on alignment system
        function calculateWeekdayIndex(day) {
            const offsetFromAlignment = day - alignmentDay;
            let weekdayIndex = (startWeekday + offsetFromAlignment) % 7;
            if (weekdayIndex < 0) {
                weekdayIndex += 7;
            }
            return weekdayIndex;
        }

        // Check if a specific day is Monday
        function isDayMonday(day) {
            return calculateWeekdayIndex(day) === MONDAY_INDEX;
        }

        // Get weekday name for a specific day
        function getWeekdayName(day) {
            return WEEKDAYS[calculateWeekdayIndex(day)];
        }

        // Convert weekday name to index with validation
        function getWeekdayIndex(weekdayName) {
            const index = WEEKDAY_MAP[weekdayName];
            return index !== undefined ? index : null;
        }

        // Create day cell with proper styling and content
        function createDayCell(day) {
            const dayCell = document.createElement('td');
            dayCell.className = 'day-cell';

            if (isMonday(day)) {
                dayCell.className += ' monday-start';
                const weekNum = getWeekNumber(day);
                dayCell.innerHTML = `<div class="week-indicator">Week ${weekNum}</div><div class="day-number">${day}</div><div class="weekday">${getWeekdayForDay(day)}</div>`;
            } else {
                dayCell.innerHTML = `<div class="day-number">${day}</div><div class="weekday">${getWeekdayForDay(day)}</div>`;
            }

            return dayCell;
        }

        // Create and populate event cell for a specific day and column
        function createEventCell(day, colIndex) {
            const eventCell = document.createElement('td');
            eventCell.className = 'event-cell';

            // Find visible events that occur on this day in this column
            const eventsOnThisDay = eventColumns[colIndex].filter(occurrence =>
                day >= occurrence.startDay && day <= occurrence.endDay && eventVisibility[sanitizeTitle(occurrence.event.title)]
            );

            if (eventsOnThisDay.length > 0) {
                const occurrence = eventsOnThisDay[0];
                const event = occurrence.event;
                const dayInEvent = day - occurrence.startDay + 1;

                eventCell.className += ` ${getEventCssClass(event)}`;

                // Add event title on first day
                if (day === occurrence.startDay) {
                    eventCell.innerHTML = `
                        <div class="event-title">${event.title}</div>
                        <div class="event-info">Day ${dayInEvent}${visibleDays > DEFAULT_VISIBLE_DAYS ? `/${event.duration}` : ''}</div>
                    `;
                } else {
                    eventCell.innerHTML = `
                        <div class="event-info">Day ${dayInEvent}${visibleDays > DEFAULT_VISIBLE_DAYS ? `/${event.duration}` : ''}</div>
                    `;
                }

                // Add stage information if available
                if (event.hasStages && event.stages && event.stages[dayInEvent - 1]) {
                    const stage = event.stages[dayInEvent - 1];
                    if (stage.note) {
                        var emoji = noteToEmoji(stage.note);
                        eventCell.innerHTML += `<div class="stage-note">${emoji}</div>`;
                    }
                }

                // Add general note if it's the first day
                if (day === occurrence.startDay && event.note) {
                    eventCell.innerHTML += `<div class="event-note">${event.note}</div>`;
                }

                // Add requirements on first day
                if (day === occurrence.startDay && event.requirements.length > 0) {
                    eventCell.innerHTML += `<div class="requirements">${event.requirements.join(', ')}</div>`;
                }
            }

            return eventCell;
        }

        // Create a complete timeline row for a given day
        function createTimelineRow(day) {
            const row = document.createElement('tr');
            row.className = 'timeline-row';

            // Add day cell
            row.appendChild(createDayCell(day));

            // Add event cells
            for (let colIndex = 0; colIndex < eventColumns.length; colIndex++) {
                row.appendChild(createEventCell(day, colIndex));
            }

            return row;
        }

        // Update UI after visibility changes
        function refreshUI() {
            generateEventList();
            generateTimeline();
        }

        // Update visibility for multiple events
        function updateEventVisibility(eventTitles, visible) {
            eventTitles.forEach(title => {
                const sanitizedTitle = typeof title === 'string' ? sanitizeTitle(title) : title;
                eventVisibility[sanitizedTitle] = visible;
            });
        }

        // Handle event dependencies by finding the latest end day
        function resolveEventDependencies(event, resolvedDependencies) {
            if (!event.appearAfter || event.appearAfter.length === 0) {
                return null;
            }
            
            let latestDependencyEnd = 0;
            for (const dependencyId of event.appearAfter) {
                if (resolvedDependencies[dependencyId]) {
                    const dependencyOccurrences = resolvedDependencies[dependencyId];
                    const lastOccurrence = dependencyOccurrences[dependencyOccurrences.length - 1];
                    if (lastOccurrence) {
                        latestDependencyEnd = Math.max(latestDependencyEnd, lastOccurrence.endDay);
                    }
                }
            }
            
            return latestDependencyEnd + 1; // Start the day after the latest dependency ends
        }

        // Modal utility functions
        function showModal(modalId) {
            const modal = document.getElementById(modalId);
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        function hideModal(modalId) {
            const modal = document.getElementById(modalId);
            modal.classList.remove('show');
            document.body.style.overflow = 'auto';
        }

        // Calculate event start day based on week/weekday or direct day specification
        function calculateEventStartDay(event) {
            if (event.firstOccurrenceWeek && event.occurrenceWeekday) {
                return getDayForWeekAndWeekday(event.firstOccurrenceWeek, event.occurrenceWeekday);
            } else {
                let startDay = event.firstOccurrenceDay;
                // If event has a specific weekday requirement, adjust the start day
                if (event.occurrenceWeekday) {
                    startDay = adjustForWeekday(startDay, event.occurrenceWeekday);
                }
                return startDay;
            }
        }

        // ========== TIMELINE STATE ==========
        let currentStartDay = 1;
        let visibleDays = DEFAULT_VISIBLE_DAYS;
        let startWeekday = 0; // Sunday
        let alignmentDay = 1; // The day that should align with the selected weekday
        let timelineData = [];
        let eventColumns = [];
        let preCalculatedOccurrences = [];
        let eventVisibility = {}; // Track visibility state of events

        // Function to sanitize event titles for use as identifiers
        function sanitizeTitle(title) {
            return title.toLowerCase()
                .replace(/[^a-z0-9\-\s]/g, '') // Remove special characters
                .replace(/\s+/g, '-') // Replace spaces with hyphens
                .replace(/-+/g, '-') // Replace multiple hyphens with single hyphen
                .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
        }

        // Function to get CSS class name for an event
        function getEventCssClass(event) {
            return 'event-' + sanitizeTitle(event.title);
        }

        const emojiMap = {
            'construction': 'üèóÔ∏è',
            'research': 'üìö',
            'roulette': 'üé≤',
            'shard': 'üíé',
            'hero': 'ü¶∏',
            'bread': 'üçû',
            'wood': 'ü™µ',
            'stone': 'ü™®',
            'iron': '‚õèÔ∏è',
            'troops': '‚öîÔ∏è',
            'training': '‚öîÔ∏è',
            'promoting': '‚¨ÜÔ∏è',
            'stamina': '‚ö°',
            'speedup': '‚è±Ô∏è',
            'gear': 'üõ°Ô∏è',
            'forgehammer': 'üî®',
            'enhancement': '‚¨ÜÔ∏è',
            'widget': 'üîß',
            'resources': 'üì¶',
            'skill': 'üìñ',
            'manual': 'üìó'
        };
        const emojiMapKeys = Object.keys(emojiMap); // Cache the keys once

        // Function to convert note text to appropriate emojis
        function noteToEmoji(note) {
            if (!note) return '';

            var notes = note.split(/,\s*/);
            let emojis = '';
            // Convert text to lowercase for matching
            const lowerNote = note.toLowerCase();

            for (let i = 0; i < notes.length; i++) {
                const originalNote = notes[i];
                const lowerNote = originalNote.toLowerCase();

                for (let j = 0; j < emojiMapKeys.length; j++) {
                    const key = emojiMapKeys[j];
                    if (lowerNote.includes(key)) {
                        emojis += `<span title="${originalNote}" alt="${originalNote}">${emojiMap[key]}</span>`;
                        break;
                    }
                }
            }


            // If no specific emoji found, use a generic info emoji
            return emojis || '‚ÑπÔ∏è';
        }

        // Initialize timeline when page loads
        document.addEventListener('DOMContentLoaded', function () {
            initializeControls();
            generateTimeline();
        });

        function initializeControls() {
            // Alignment day input
            document.getElementById('alignmentDay').addEventListener('input', function () {
                alignmentDay = parseInt(this.value) || 1;
                updateDayWeekdayLabel();
                generateTimeline();
            });

            // Start weekday selector
            document.getElementById('startWeekday').addEventListener('change', function () {
                startWeekday = parseInt(this.value);
                updateDayWeekdayLabel();
                generateTimeline();
            });

            // Initialize event visibility (all events visible by default)
            eventsData.events.forEach(event => {
                eventVisibility[sanitizeTitle(event.title)] = true;
            });

            // Update the initial label
            updateDayWeekdayLabel();

            // Generate event list
            generateEventList();
        }

        function generateEventList() {
            const container = document.getElementById('eventListContainer');
            container.innerHTML = '';

            eventsData.events.forEach(event => {
                const sanitizedTitle = sanitizeTitle(event.title);
                const eventToggle = document.createElement('div');
                eventToggle.className = `event-toggle ${event.category} ${eventVisibility[sanitizedTitle] ? '' : 'disabled'}`;
                eventToggle.onclick = () => toggleEvent(sanitizedTitle);

                eventToggle.innerHTML = `
                    <div class="toggle-switch ${eventVisibility[sanitizedTitle] ? 'active' : ''}">
                        <div class="toggle-slider"></div>
                    </div>
                    <div class="event-toggle-content">
                        <div class="event-toggle-title">${event.title}</div>
                        <div class="event-toggle-info">
                            Duration: ${event.duration} days
                            ${event.isRepeating ? ` ‚Ä¢ Repeats every ${event.occurrenceInterval} days` : ''}
                            ${event.requirements.length > 0 ? `<br>${event.requirements.join(', ')}` : ''}
                        </div>
                    </div>
                `;
                container.appendChild(eventToggle);
            });
        }

        function getWeekdayForDay(day) {
            return getWeekdayName(day);
        }

        function isMonday(day) {
            return isDayMonday(day);
        }

        function getWeekNumber(day) {
            // Find the first Monday on or after day 1
            let firstMondayDay = 1;
            while (!isMonday(firstMondayDay)) {
                firstMondayDay++;
            }

            // If the day is before the first Monday, it's considered week 1
            if (day < firstMondayDay) {
                return 1;
            }

            // Calculate week number based on days since first Monday
            // The first Monday starts week 2 if there were partial days before it
            const baseWeek = firstMondayDay > 1 ? 2 : 1;
            return Math.floor((day - firstMondayDay) / 7) + baseWeek;
        }

        function updateDayWeekdayLabel() {
            const labelElement = document.getElementById('dayWeekdayLabel');
            if (labelElement) {
                labelElement.textContent = `Day ${alignmentDay} Weekday:`;
            }
        }

        function calculateEventOccurrences(event, maxDay, resolvedDependencies = {}) {
            const occurrences = [];

            if (!event.isRepeating) {
                // Single occurrence event
                let startDay;

                // Handle appearAfter dependencies
                const dependencyStartDay = resolveEventDependencies(event, resolvedDependencies);
                if (dependencyStartDay !== null) {
                    startDay = dependencyStartDay;
                } else {
                    startDay = calculateEventStartDay(event);
                }

                if (startDay <= maxDay) {
                    occurrences.push({
                        startDay: startDay,
                        endDay: startDay + event.duration - 1,
                        event: event
                    });
                }
            } else {
                // Repeating event
                let occurrenceCount = 0;
                let currentStartDay;

                // Handle appearAfter dependencies for repeating events
                const dependencyStartDay = resolveEventDependencies(event, resolvedDependencies);
                if (dependencyStartDay !== null) {
                    currentStartDay = dependencyStartDay;
                } else {
                    currentStartDay = calculateEventStartDay(event);
                }

                while (currentStartDay <= maxDay && (!event.maxOccurrences || occurrenceCount < event.maxOccurrences)) {
                    occurrences.push({
                        startDay: currentStartDay,
                        endDay: currentStartDay + event.duration - 1,
                        event: event
                    });

                    currentStartDay += event.occurrenceInterval;
                    occurrenceCount++;
                }
            }

            return occurrences;
        }

        function adjustForWeekday(baseDay, targetWeekdayName) {
            const targetWeekday = getWeekdayIndex(targetWeekdayName);
            if (targetWeekday === null) {
                return baseDay; // Return original if weekday name is invalid
            }

            const baseDayWeekday = calculateWeekdayIndex(baseDay);

            // Calculate how many days to adjust to reach the target weekday
            let adjustment = targetWeekday - baseDayWeekday;
            if (adjustment < 0) {
                adjustment += 7; // Move to next week if target day has passed
            }

            return baseDay + adjustment;
        }

        // Helper function to get the fixed column for an event ID, or null if not fixed
        function getFixedColumnForEvent(eventId) {
            for (const [colIndex, eventIds] of Object.entries(fixedColumns)) {
                if (eventIds.includes(eventId)) {
                    return parseInt(colIndex);
                }
            }
            return null;
        }

        // Helper function to check if an event is assigned to a fixed column
        function isEventInFixedColumn(eventId) {
            return getFixedColumnForEvent(eventId) !== null;
        }

        function getDayForWeekAndWeekday(weekNumber, weekdayName) {
            const targetWeekday = getWeekdayIndex(weekdayName);
            if (targetWeekday === null) {
                return 1; // Return day 1 if weekday name is invalid
            }

            // Find the first Monday on or after day 1
            let firstMondayDay = 1;
            while (!isMonday(firstMondayDay)) {
                firstMondayDay++;
            }

            // Calculate the start of the requested week
            let weekStartDay;
            if (weekNumber === 1) {
                // Week 1 starts from day 1
                weekStartDay = 1;
            } else {
                // Week 2 starts from the first Monday, subsequent weeks follow
                const baseWeek = firstMondayDay > 1 ? 2 : 1;
                if (weekNumber < baseWeek) {
                    weekStartDay = 1;
                } else {
                    weekStartDay = firstMondayDay + ((weekNumber - baseWeek) * 7);
                }
            }

            // Find the Monday of the target week
            let mondayOfWeek = weekStartDay;
            if (weekNumber > 1 || firstMondayDay === 1) {
                // For week 2+ or if first Monday is day 1, find the Monday of this week
                while (!isMonday(mondayOfWeek) && mondayOfWeek <= weekStartDay + 6) {
                    mondayOfWeek++;
                }
                // If no Monday found in the week range, use the calculated Monday
                if (!isMonday(mondayOfWeek)) {
                    mondayOfWeek = firstMondayDay + ((weekNumber - (firstMondayDay > 1 ? 2 : 1)) * 7);
                }
            }

            // Calculate the target day based on the Monday of the week
            let dayOffset = targetWeekday - MONDAY_INDEX;
            if (dayOffset < 0) {
                dayOffset += 7; // Handle Sunday (0) by going to previous week's Sunday
            }

            return mondayOfWeek + dayOffset;
        }

        function preCalculateAllOccurrences() {
            // Pre-calculate all event occurrences up to MAX_PRECALCULATED_DAY
            const allOccurrences = [];
            const resolvedDependencies = {};

            // Create a set to track which events have been processed
            const processedEvents = new Set();

            // Function to process events in dependency order
            function processEvent(event) {
                // Skip if already processed
                const eventKey = event.id || event.title;
                if (processedEvents.has(eventKey)) {
                    return;
                }

                // Process dependencies first
                if (event.appearAfter && event.appearAfter.length > 0) {
                    for (const dependencyId of event.appearAfter) {
                        const dependencyEvent = eventsData.events.find(e =>
                            (e.id === dependencyId) || (e.title === dependencyId)
                        );
                        if (dependencyEvent && !processedEvents.has(dependencyId)) {
                            processEvent(dependencyEvent);
                        }
                    }
                }

                // Calculate occurrences for this event
                const occurrences = calculateEventOccurrences(event, MAX_PRECALCULATED_DAY, resolvedDependencies);
                allOccurrences.push(...occurrences);

                // Store resolved dependencies for future events
                resolvedDependencies[eventKey] = occurrences;
                processedEvents.add(eventKey);
            }

            // Process all events
            eventsData.events.forEach(event => {
                processEvent(event);
            });

            // Sort by start day, then by event priority (fixed events first)
            allOccurrences.sort((a, b) => {
                if (a.startDay !== b.startDay) return a.startDay - b.startDay;
                // Fixed events get priority
                const aEventKey = a.event.id || a.event.title;
                const bEventKey = b.event.id || b.event.title;
                const aIsFixed = isEventInFixedColumn(aEventKey);
                const bIsFixed = isEventInFixedColumn(bEventKey);
                if (aIsFixed && !bIsFixed) return -1;
                if (!aIsFixed && bIsFixed) return 1;
                return 0;
            });

            return allOccurrences;
        }

        function determineEventColumns() {
            // Pre-calculate all occurrences if not done already
            if (preCalculatedOccurrences.length === 0) {
                preCalculatedOccurrences = preCalculateAllOccurrences();
            }

            // Determine which columns are reserved based on fixedColumns dictionary
            const reservedColumns = new Set(Object.keys(fixedColumns).map(k => parseInt(k)));

            // Determine the maximum number of fixed columns needed
            let maxFixedColumn = Math.max(...Array.from(reservedColumns), -1);

            // Initialize columns array with enough space for fixed columns
            const columns = [];
            for (let i = 0; i <= maxFixedColumn; i++) {
                columns[i] = [];
            }

            // First pass: assign fixed events to their designated columns
            preCalculatedOccurrences.forEach(occurrence => {
                const eventKey = occurrence.event.id || occurrence.event.title;
                const fixedColumn = getFixedColumnForEvent(eventKey);
                
                if (fixedColumn !== null) {
                    columns[fixedColumn].push(occurrence);
                    occurrence.assignedColumn = fixedColumn; // Track assignment
                }
            });

            // Second pass: efficiently pack non-fixed events into available spaces (skip reserved columns)
            preCalculatedOccurrences.forEach(occurrence => {
                const eventKey = occurrence.event.id || occurrence.event.title;
                
                // Skip if already assigned as a fixed event
                if (isEventInFixedColumn(eventKey)) {
                    return;
                }
                
                let assignedColumn = -1;

                // Try to find the first available column that can accommodate this event
                // Skip columns that are reserved for fixed events
                for (let colIndex = 0; colIndex < columns.length; colIndex++) {
                    if (!reservedColumns.has(colIndex) && canFitInColumn(occurrence, columns[colIndex])) {
                        columns[colIndex].push(occurrence);
                        occurrence.assignedColumn = colIndex;
                        assignedColumn = colIndex;
                        break;
                    }
                }

                // If no existing column can fit this event, create a new one
                if (assignedColumn === -1) {
                    columns.push([occurrence]);
                    occurrence.assignedColumn = columns.length - 1;
                }
            });

            // Ensure all reserved columns exist (even if empty)
            reservedColumns.forEach(colIndex => {
                if (!columns[colIndex]) {
                    columns[colIndex] = [];
                }
            });

            // Fill any gaps in the columns array to maintain proper indexing
            const maxColumnIndex = Math.max(columns.length - 1, maxFixedColumn);
            for (let i = 0; i <= maxColumnIndex; i++) {
                if (!columns[i]) {
                    columns[i] = [];
                }
            }

            return columns;
        }

        function canFitInColumn(newOccurrence, columnOccurrences) {
            // Check if the new occurrence overlaps with any existing occurrence in the column
            return !columnOccurrences.some(existing =>
                !(newOccurrence.endDay < existing.startDay || newOccurrence.startDay > existing.endDay)
            );
        }

        function generateTimeline() {
            const table = document.getElementById('timelineTable');
            const header = document.getElementById('timelineHeader');
            const body = document.getElementById('timelineBody');

            // Update the day weekday label
            updateDayWeekdayLabel();

            // Clear existing content
            header.innerHTML = '';
            body.innerHTML = '';

            // Reset pre-calculated occurrences when timeline parameters change
            preCalculatedOccurrences = [];

            // Calculate event columns (this will trigger pre-calculation)
            eventColumns = determineEventColumns();

            // Create header row
            const headerRow = document.createElement('tr');
            headerRow.innerHTML = '<th class="day-header">Day</th>';

            // Add event column headers
            for (let i = 0; i < eventColumns.length; i++) {
                const th = document.createElement('th');
                th.className = 'event-header';
                th.textContent = `Events ${i + 1}`;
                headerRow.appendChild(th);
            }

            header.appendChild(headerRow);

            // Generate timeline rows
            for (let day = currentStartDay; day < currentStartDay + visibleDays; day++) {
                body.appendChild(createTimelineRow(day));
            }

            // Add infinite scroll
            addInfiniteScroll();
        }

        function addInfiniteScroll() {
            const container = document.getElementById('timelineContainer');

            container.addEventListener('scroll', function () {
                if (container.scrollTop + container.clientHeight >= container.scrollHeight - 100) {
                    // Load more days
                    loadMoreDays();
                }
            });
        }

        function toggleEvent(sanitizedTitle) {
            eventVisibility[sanitizedTitle] = !eventVisibility[sanitizedTitle];
            refreshUI();
        }

        function toggleAllEvents(show) {
            const eventTitles = eventsData.events.map(event => sanitizeTitle(event.title));
            updateEventVisibility(eventTitles, show);
            refreshUI();
        }

        function toggleByCategory(category) {
            const eventsInCategory = eventsData.events.filter(event => event.category === category);
            const allVisible = eventsInCategory.every(event => eventVisibility[sanitizeTitle(event.title)]);
            const eventTitles = eventsInCategory.map(event => sanitizeTitle(event.title));
            
            updateEventVisibility(eventTitles, !allVisible);
            refreshUI();
        }

        function loadMoreDays() {
            const body = document.getElementById('timelineBody');
            const startDay = currentStartDay + visibleDays;

            for (let day = startDay; day < startDay + ADDITIONAL_DAYS_ON_SCROLL; day++) {
                body.appendChild(createTimelineRow(day));
            }

            visibleDays += ADDITIONAL_DAYS_ON_SCROLL;
        }

        // Modal functions
        function openEventInfoModal() {
            showModal('eventInfoModal');
        }

        function closeEventInfoModal() {
            hideModal('eventInfoModal');
        }

        // Close modal when clicking outside of it
        document.getElementById('eventInfoModal').addEventListener('click', function (e) {
            if (e.target === this) {
                closeEventInfoModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('eventInfoModal');
                if (modal.classList.contains('show')) {
                    closeEventInfoModal();
                }
            }
        });
    </script>
</body>

</html>
